#!/usr/bin/env python
# Automatically generated by rugmigen.py
# Plugins used: config core routing parse_form urlfor_cgi index fix_path_info main

import os
import re
import cgi
import base64
import shutil
import hashlib
import tempfile
import itertools
from functools import wraps
try:
    from ConfigParser import ConfigParser
except ImportError:
    from configparser import ConfigParser

# Config

config = ConfigParser()
config.read([
    os.path.expanduser(os.environ.get('RUGMI_CONF', '~/.rugmi.conf')),
    "/etc/rugmi.conf",
])

# get config
keys = list(map(lambda a: a.strip(), config.get("server", "keys").split(",")))
url = config.get("server", "url").rstrip("/").encode("utf8")
store_path = config.get("server", "store_path").rstrip("/").encode("utf8")
debug = config.getboolean("server", "debug")

wsgi_wrappers = []

# Errors

class UnauthorizedError(Exception):
    pass

class InternalError(Exception):
    pass

class NotFoundError(Exception):
    pass

# Helpers

def errorable(error):
    error_str = b""
    for e in error.args:
        if not isinstance(e, bytes):
            e = e.encode("utf8")
        error_str += b" " + e
    return error_str

def response(func):
    @wraps(func)
    def wrapper(environ, start_response):
        if environ["REQUEST_METHOD"] == "POST":
            if environ.get("wsgi.version", None):
                env = environ.copy()
                env['QUERY_STRING'] = ''
                form = cgi.FieldStorage(
                    fp=env['wsgi.input'],
                    environ=env,
                    keep_blank_values=True
                )
            else:
                form = cgi.FieldStorage()
            environ["rugmi.form"] = form

        try:
            data = func(environ, start_response)
            content_type = "text/html"
            if type(data) is tuple:
                data, content_type = data
            start_response('200 OK', [('Content-Type', content_type)])
        except UnauthorizedError as error:
            start_response('401 Unauthorized',
                    [('Content-Type', 'text/plain')])
            data = errorable(error) or b"Unauthorized, man"
        except InternalError as error:
            start_response('500 Internal Error',
                    [('Content-Type', 'text/plain')])
            data = errorable(error) or b"Error"
        except NotFoundError as error:
            start_response('404 NOT FOUND', [('Content-Type', 'text/plain')])
            data = errorable(error) or b"Not Found"
        except Exception as error:
            start_response('500 Internal Error',
                    [('Content-Type', 'text/plain')])
            data = b"Unhandled Error"
            if debug:
                data += b"\n\n"
                data += errorable(error)
        return [data]
    return wrapper

class InvalidUrlDefinition(Exception):
    pass

class UrlNotFound(Exception):
    pass

routes = {}

# stolen from werkzeug
_rule_re = re.compile(r'''
    (?P<static>[^<]*)                           # static rule data
    <
    (?P<variable>[a-zA-Z_][a-zA-Z0-9_]*)        # variable name
    >
''', re.VERBOSE)

def flatten(l):
    return list(itertools.chain(*l))

def build_rule(rule):
    rule_re = ""
    match = _rule_re.match
    pos = 0
    end = len(rule)
    while pos < end:
        m = match(rule, pos)
        if m is None:
            break
        pos = m.end()
        data = m.groupdict()
        static = data.get("static", "")
        if static:
            rule_re += static
        variable = data["variable"]
        rule_re += r"(?P<%s>[^/]+)" % re.escape(variable)
    if pos < end:
        rule_re += rule[pos:]
    if not rule_re:
        raise InvalidUrlDefinition
    return "^%s$" % rule_re

def rule_to_url(rule, **kwargs):
    def replace(matchobj):
        static =  matchobj.group(1)
        variable = matchobj.group(2)
        return static + str(kwargs[variable])
    return _rule_re.sub(replace, rule)

def route(rule, methods=["GET"]):
    def decorator(func):
        name = func.__name__
        rule_re = re.compile(build_rule(rule))
        route = dict(rule=rule, rule_re=rule_re, func=func,
                methods=methods)
        routes.setdefault(name, [])
        routes[name].append(route)

        @wraps(func)
        def wrapper(environ, start_response):
            return func(environ, start_response)

        return wrapper
    return decorator

def _url_for(name, **kwargs):
    if not name in routes:
        raise InvalidUrlDefinition
    for route in routes[name]:
        try:
            return rule_to_url(route["rule"], **kwargs)
        except KeyError:
            continue
    raise UrlNotFound

@response
def not_found(environ, start_response):
    raise NotFoundError

# Application

def application(environ, start_response):
    path = environ.get('PATH_INFO', '/')
    method = environ["REQUEST_METHOD"]
    for route in flatten(routes.values()):
        if method not in route["methods"]:
            continue
        match = route["rule_re"].match(path)
        if match is not None:
            environ['rugmi.url_args'] = match.groupdict()
            return route["func"](environ, start_response)
    return not_found(environ, start_response)

@route("/", methods=["POST"])
@response
def parse_form(environ, start_response):
    form = environ["rugmi.form"]
    key = form.getfirst("key", None)
    if key not in keys:
        raise UnauthorizedError

    if not form.getfirst("file", None):
        raise InternalError(b"Needs a file!")

    filefield = form["file"]

    extension = None
    if "." in filefield.filename:
        extension = filefield.filename.rsplit(".", 1)[1].encode("utf8")
        if not extension.isalpha():
            raise InternalError("Invalid Extension")

    strhash = hashlib.md5()

    temp = tempfile.NamedTemporaryFile(delete=False)
    while True:
        part = filefield.file.read(128)
        if not part:
            break
        strhash.update(part)
        temp.write(part)
    temp.close()

    if filefield.done == -1:
        raise InternalError(b"Upload Aborted")

    filename = base64.b64encode(strhash.digest())[:5]
    filename = filename.replace(b"/", b"_").replace(b"+", b"-")
    if extension:
        filename += b"." + extension

    try:
        path = b"/".join([store_path, filename])
        shutil.move(temp.name, path)
    except IOError as e:
        raise InternalError(b"Error saving: " + errorable(e))

    return b"/".join([url, filename]), "text/plain"



def url_for(name, **kwargs):
    return "?path=%s" % _url_for(name, **kwargs)

@route("/")
@response
def index(environ, start_response):
    return b"""
    <!DOCTYPE html>
    <html lang="en">
      <head>
      <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css">
      </head>
      <body>
        <div class="container">
          <div class="page-header">
            <h1>Rugmi <small>Your dumpster!</small></h1>
          </div>
          <div class="well">
            <form enctype="multipart/form-data" method="post" role="form">
              <div class="form-group">
                <p>Key: <input class="form-control" name="key" type="input"></p>
                <p>File: <input name='file' type='file'></p>
                <p><button type='submit' class='btn btn-primary'>Send</button></p>
              </div>
            </form>
          </div>
        </div>
      </body>
    </html>"""

class InvalidPathInfo(Exception):
    pass

class PathInfoInEnviron(Exception):
    pass

def fix_path_info(application):
    @wraps(application)
    def wrapper(environ, start_response):
        qs = cgi.parse_qs(environ["QUERY_STRING"])
        #if "PATH_INFO" in environ:
        #    raise PathInfoInEnviron

        environ["PATH_INFO"] = "/"
        if "path" in qs:
            if len(qs["path"]) != 1:
                raise InvalidPathInfo

            environ["PATH_INFO"] = qs["path"][0]
            del qs["path"]
            # rebuild query string without path
            environ["QUERY_STRING"] = "&".join(["%s=%s" % (key, v) \
                    for key, value in qs.items() for v in value])
        return application(environ, start_response)
    return wrapper

wsgi_wrappers.append(fix_path_info)



if __name__ == '__main__':
    import sys
    for wrapper in wsgi_wrappers:
        application = wrapper(application)

    if len(sys.argv) == 2 and sys.argv[1] == "http":
        from wsgiref.simple_server import make_server
        srv = make_server('localhost', 8000, application)
        srv.serve_forever()
    else:
        from wsgiref.handlers import CGIHandler
        CGIHandler().run(application)
